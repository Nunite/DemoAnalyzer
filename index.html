<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>DemoAnalyzer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="bootstrap.min.css" rel="stylesheet">
    <script src="bootstrap.bundle.min.js"></script>
    <script type="module" src="libarchivejs/dist/index.js"></script>
    <script src="hldemo.js"></script>
    <script src="chart.js"></script>
    <script src="chartjs-plugin-datalabels.js"></script>
    <script src="jquery-3.7.1.slim.min.js"></script>
    <script type="module">
        import { Archive } from "./libarchivejs/dist/libarchive.js";
        window.Archive = Archive;
    </script>
</head>
<body>
<main>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
          <a class="navbar-brand" href="#">DemoAnalyzer</a>
        </div>
    </nav>
    <section class="py-5 text-center container">
    <div class="row py-lg-5">
      <div class="col-lg-6 col-md-8 mx-auto">
        <h1 class="fw-light">Analyze CS 1.6 KZ demos</h1>
        <p class="lead text-body-secondary">Free and open-source tool for the community, made by the community. The project lives in <a href="#">GitHub</a>.</p>
        <p>
          <div id="drop-area">
            <p>Select or drop files here <small>(.dem, .zip, .rar)</small></p>
            <input type="file" id="file-input" multiple style="display:none">
        </div>
        <p>
          <a href="#demos" class="btn btn-secondary my-2">View your demos</a>
        </p>
      </div>
    </div>
  </section>
  <div class="container data"></div>
    <div class="container">
      <footer class="py-5">
        <p>DemoAnalyzer<br>version 0.0.2</p>
        <!-- MEOW by hönö dille!!! -->
      </footer>
    </div>
</main>
<style>
#drop-area {
    width: 100%;
    height: 127px;
    border: 2px dashed #012cfd;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-family: Arial, sans-serif;
    margin: 40px 0px 30px 0px;
    cursor: pointer;
}
#drop-area p {
    padding: 0;
    margin: 0;
    color: #343434;
}
#drop-area small {
    font-size: 0.6rem;
}
#drop-area:hover, #drop-area:focus {
    background: #e9eef7;
}

#drop-area p {
    padding: 0;
    margin: 0;
}

#drop-area:hover, #drop-area:focus {
    background: #e9eef7;
}

#drop-area.highlight {
    border-color: #6c63ff;
}

#file-list {
    margin-top: 20px;
}

.t-set h4 {
font-size: 12px;
  font-style: italic;
}
.t-set .t-amount {
  font-size: 16px;
  display: inline-block;
  border: 1px solid;
  padding: 2px 14px;
  font-weight: bolder;
}
.t-set {
  border-top: 1px solid #efefef;
  /*! padding: 30px; */
  margin-bottom: 17px;
  padding-top: 17px;
}
.t-set:first-child {
  padding-top: 0px;
  border-top: none;
}
.t-set .t-fogtable {
  font-size: 12px;
  margin-top: 18px;
}
.t-set .toggle-joff-frames {
    font-size: 12px;
    padding: 1px 6px;
    box-shadow: 3px 3px #f6f6f6;
    background: white;
    color: blue;
    border-color: #f4f4f4;
}
.t-set.amount-1,
.t-set.amount-2,
.t-set.amount-3,
.t-set.amount-4,
.t-set.amount-5 {
  display: none;
}
.expand-all-sets .t-set.amount-1,
.expand-all-sets .t-set.amount-2,
.expand-all-sets .t-set.amount-3,
.expand-all-sets .t-set.amount-4,
.expand-all-sets .t-set.amount-5 {
  display: block;
}

.extra-container {
  max-height: 100%;
  max-width: 760px;
  overflow: scroll;
}
.fogPieChart {
  max-height: 300px;
}

</style>
        
<script>
    const config = {
        ENABLE_STORAGE: true,
    };
    
    const dropArea = document.getElementById('drop-area');
    const fileInput = document.getElementById('file-input');

    ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropArea.classList.add('highlight');
        }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropArea.classList.remove('highlight');
        }, false);
    });

    dropArea.addEventListener('drop', (e) => {
        const files = e.dataTransfer.files;
        handleFiles(files);
    });
    
    dropArea.addEventListener('click', () => {
        fileInput.click();
    });

    fileInput.addEventListener('change', (e) => {
        handleFiles(fileInput.files);
    });

    function openDatabase() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('fileStore', 1);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                db.createObjectStore('files', { keyPath: 'id' });
            };
            
            request.onsuccess = (event) => {
                resolve(event.target.result);
            };
            
            request.onerror = (event) => {
                reject(event.target.error);
            };
        });
    }

    function storeFile(file) {
        return openDatabase().then((db) => {
            return new Promise((resolve, reject) => {
                if (config.ENABLE_STORAGE !== true) {
                    return true;
                }
                
                const transaction = db.transaction(['files'], 'readwrite');
                const store = transaction.objectStore('files');
                const fileData = {
                    id: file.name,
                    file: file
                };
                const request = store.put(fileData);
                
                request.onsuccess = () => {
                    resolve('File stored successfully');
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        });
    }

    function retrieveFile(fileId) {
        return openDatabase().then((db) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['files'], 'readonly');
                const store = transaction.objectStore('files');
                const request = store.get(fileId);
                
                request.onsuccess = (event) => {
                    const result = event.target.result;
                    if (result) {
                        resolve(result.file);
                    } else {
                        reject('File not found');
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        });
    }

    function retrieveAllFiles() {
        return openDatabase().then((db) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['files'], 'readonly');
                const store = transaction.objectStore('files');
                const request = store.openCursor();

                const files = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        files.push(cursor.value.file);
                        cursor.continue();
                    } else {
                        resolve(files);
                    }
                };
                
                request.onerror = () => {
                    reject(request.error);
                };
            });
        });
    }

    async function handleFiles(files) {
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const file_extension = file.name.split('.').pop().toLowerCase();
            if (file_extension === 'dem') {
                        console.log('File name:', file.name);
                        console.log('File size:', file.size);
                        console.log('File type:', file.type);
                        storeFile(file)
            .then((message) => console.log(message))
            .catch((error) => console.error('Error storing file:', error));
                parseDemo(file, i);
            } else if (['zip','rar','7z','tar','gz','xz','bz2'].includes(file_extension)) {
                // open the file archive for reading
                try {
                    const archive = await Archive.open(file);

                    const extractedFiles = await archive.extractFiles();

                    const filesObject = await archive.getFilesObject();

                    for (const [fileName, fileData] of Object.entries(filesObject)) {
                        console.log(`Extracted file: ${fileName}`, fileData);
                        console.log('File name:', fileData.name);
                        console.log('File size:', fileData.size);
                        console.log('File type:', fileData.type);
                        storeFile(fileData)
                            .then((message) => console.log(message))
                            .catch((error) => console.error('Error storing file:', error));
                        parseDemo(fileData, i, true);
                    }
                } catch (err) {
                    console.error(err);
                }
            }
        }
    }
    
    
    
    function generateTickFogsTable (data) {
        let html = '';
        html += `
            <table class="table table-responsive table-bordered table-sm t-fogtable">
                <thead>
                    <tr>
        `;
        Object.keys(data).forEach(key => {
            html += `<th>FOG${key}s</th>`;
        });
        html += `
                    </tr>
                </thead>
                <tbody>
                    <tr>
        `;
        Object.values(data).forEach(value => {
            html += `<td><div class="t-fog">${value}</div></td>`;
        });
        html += `
                    </tr>
                </tbody>
            </table>
        `;
        return html;
    }

            
    $(document).on('click', '.toggle-joff-frames', function(event) {
        event.preventDefault();
        $(this).parent().find('.joff-frames').toggle();
    });
    
    $(document).on('click', '.toggle-low-amounts', function(event) {
        event.preventDefault();
        $(this).parent().toggleClass('expand-all-sets');
    });
    
    $(document).on('click', '.toggle-graphs', function(event) {
        event.preventDefault();
        const extra_tr = $(this).closest('tr').first().parent().find('.extra').toggle();
    });

    function parseDemo(file, index, is_archive=false) {
        const demoReader = new HLDemo.DemoReader();
        demoReader.onready(function() {
            const frames = demoReader.directoryEntries[1].frames;
            
            //console.log(demoReader);
            
            const jumps_data = parseFrames(frames);
            jumps_data.demo_size = demoReader.demoSize;
            jumps_data.map = demoReader.header.mapName;
            jumps_data.filename = file.name;
            
            const jumps = parseJumpData(jumps_data);
            const jump_stats = getJumpStats(jumps);
            
            console.log(jump_stats);
            
            let table_html = `<table class="table table-bordered table-responsive">
                <tr>
                    <thead>
                        <tr>
                            <th>&nbsp;</th>
                            <th title="Bhops with consecutive 1st tick +jump">1TBJs</th>
                            <th title="Bhops with consecutive 2nd tick +jump">2TBJs</th>
                            <th title="Bhops with consecutive 3rd tick +jump">3TBJs</th>
                            <th title="Bhops with consecutive 4rd tick +jump">4TBJs</th>
                            <th title="Bhops with consecutive 5th tick +jump">5TBJs</th>
                        </tr>
                    </thead>
                </tr>
                <tbody>
            `;
            
            
            
            const tdata = jump_stats.consecutive_jump_ticks;
            
            table_html += `<tr><td style="width: 16%;">${jumps_data.filename}<div class="demo-extra-btn"><button class="btn btn-primary btn-sm toggle-graphs">Toggle graphs</button></div></td>`;
            
            function generateTickTable(tickData, tickNumber) {
                let html = '';
                const amounts = [];
                for (let i = 0; i < tickData.sets.length; i++) {
                    const amount = tickData.sets[i].amount;
                    amounts.push(amount);
                    
                    html += `<div class="t-set t${tickNumber} amount-${amount}">`;
                    html += `<h4>Set ${i + 1}</h4>`;

                    // Amount of consecutive bjumps
                    let amountColor = '';
                    if (amount <= 5) {
                        amountColor = '#c2fcc2';
                    } else if (amount > 5 && amount <= 10) {
                        amountColor = '#effcc2';
                    } else if (amount > 10 && amount <= 15) {
                        amountColor = '#ffbd76';
                    } else if (amount > 15) {
                        amountColor = '#ff7676';
                    } else {
                        amountColor = '#fff';
                    }
                    html += `<div class="t-amount" style="background:${amountColor}">${amount} &times;</div>`;

                    // Fogs table
                    html += generateTickFogsTable(tickData.sets[i].fogs);

                    // Joffs list
                    html += `
                        <div class="t${tickNumber}-set-jof-frames">
                            <button class="btn btn-primary toggle-joff-frames">joff frames</button>
                            <div class="joff-frames" style="display:none;">${tickData.sets[i].jumpoffs.join(',')}</div>
                        </div>`;
                    html += `</div>`;
                }
                html += '</td>';
                
                let td_start = '';
                if (amounts.some(value => value <= 5)) {
                    td_start = '<td style="width:16%;"><button class="btn btn-primary btn-sm toggle-low-amounts">Toggle &lt;=5 sets</button>';
                } else {
                    td_start = '<td style="width:16%;">';
                }
                
                return td_start + html;
            }

            // Generate the full table for all ticks
            for (let tickNumber = 1; tickNumber <= 5; tickNumber++) {
                table_html += generateTickTable(tdata[`tick${tickNumber}`], tickNumber);
            }
           
            table_html += '</tr>';
            const extra_html = `
                <div class="extra-container">
                    <canvas class="consecutiveJumpTicksChart" id="consecutiveJumpTicksChart${index}"></canvas>
                    <br>
                    <canvas class="fogCountChartBar" id="fogCountChartBar${index}"></canvas>
                    <br>
                    <canvas class="fogCountChartPie" id="fogCountChartPie${index}"></canvas>
                    <br>
                    <canvas class="fogPieChart" id="fogPieChart${index}"></canvas>
                    <br>
                </div>
            `;
            table_html += `<tr class="extra" style="display:none;"><td colspan="6">${extra_html}</td></tr>`;
            table_html += '</tbody></table>';
            $('.container.data').prepend(table_html);
            
            const fogCounts = jump_stats.fog_counts;
            console.log("FOG counts:", fogCounts);
            const fog_labels = Object.keys(fogCounts).map(key => `FOG ${key}`);
            const fog_data = Object.values(fogCounts);

            const ctx = document.getElementById('fogCountChartBar'+index).getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: fog_labels,
                    datasets: [{
                        label: 'Amount',
                        data: fog_data,
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            display: true,
                            anchor: 'end',
                            align: 'top',
                            formatter: (value, context) => {
                                const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${percentage}%`;
                            },
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            padding: 4
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: false,
                                text: 'FOG'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count'
                            },
                            beginAtZero: true
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });


            const labelsf = [];
            const dataf = [];
            const backgroundColors = [];
            const borderColors = '#007400';

            for (const [key, value] of Object.entries(fogCounts)) {
                if (value > 0) {
                    labelsf.push(`FOG${key}`);
                    dataf.push(value);
                    backgroundColors.push(getColorForIndex(Number(key)));
                }
            }

            function getColorForIndex(index) {
                const colors = [
                    '#39b739', '#7cc67c', '#eef448', '#f4cc48', '#f4a948',
                    '#f46d48', '#f45448', '#f44848', '#b80000', '#9f0000'
                ];
                return colors[index % colors.length];
            }

            const ctx3 = document.getElementById('fogPieChart'+index).getContext('2d');
            new Chart(ctx3, {
                type: 'pie',
                data: {
                    labels: labelsf,
                    datasets: [{
                        label: 'Amount',
                        data: dataf,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    plugins: {
                        legend: {
                            display: false
                        },
                        datalabels: {
                            color: '#000',
                            display: true,
                            formatter: (value, context) => {
                                const total = context.dataset.data.reduce((acc, val) => acc + val, 0);
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${context.chart.data.labels[context.dataIndex]}: ${value} (${percentage}%)`;
                            },
                            anchor: 'center',
                            align: 'center',
                            backgroundColor: (context) => {
                                return context.dataset.backgroundColor[context.dataIndex];
                            },
                            borderColor: (context) => {
                                return context.dataset.borderColor;
                            },
                            borderWidth: 2,
                            borderRadius: 4,
                            font: {
                                weight: 'bold',
                                size: 14
                            },
                            padding: 6
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
                
            const consecutiveJumpTicks = jump_stats.consecutive_jump_ticks;

            const tick_labels = ['1TJ', '2TJ', '3TJ', '4TJ', '5TJ'];

            const dataSets = [];
            let maxSets = 0;

            Object.values(consecutiveJumpTicks).forEach(tick => {
                if (tick.sets.length > maxSets) {
                    maxSets = tick.sets.length;
                }
            });

            for (let i = 0; i < maxSets; i++) {
                const data = [];
                Object.keys(consecutiveJumpTicks).forEach(tick => {
                    const sets = consecutiveJumpTicks[tick].sets;
                    if (sets[i]) {
                        data.push(sets[i].amount);
                    } else {
                        data.push(0);
                    }
                });

                dataSets.push({
                    label: `Set ${i + 1}`,
                    data: data,
                    backgroundColor: `rgba(${(i * 50) % 255}, ${(i * 100) % 255}, ${(i * 150) % 255}, 1)`,
                    borderColor: `rgba(${(i * 50) % 255}, ${(i * 100) % 255}, ${(i * 150) % 255}, 1)`,
                });
            }

            const config = {
                type: 'bar',
                data: {
                    labels: tick_labels,
                    datasets: dataSets
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: 'Consecutive Jump Ticks'
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Tick Jumps'
                            }
                        },
                        y: {
                            min: 0,
                            suggestedMax: 10,
                            title: {
                                display: true,
                                text: 'Amount of Consecutive Jumps'
                            }
                        }
                    }
                }
            };

            const myBarChart = new Chart(
                document.getElementById('consecutiveJumpTicksChart'+index),
                config
            );
            
        
            console.log("jumps:",jumps);
            console.log("jump stats:",jump_stats);
            
        });
        demoReader.parse(file);
    }
    

    function getJumpStats(jumps) {
        const data = {
            jump_tick_counts: [],
            fog_counts: {
                1: 0, 2: 0,
                3: 0, 4: 0,
                5: 0, 6: 0,
                7: 0, 8: 0,
                9: 0, 10: 0
            },
            consecutive_jump_ticks: {
                'tick1': { 'sets': [] },
                'tick2': { 'sets': [] },
                'tick3': { 'sets': [] },
                'tick4': { 'sets': [] },
                'tick5': { 'sets': [] }
            },
        };

        let prev_jump_tick = null;
        let current_set = null;
        let non_lj_count = 0;

        jumps.forEach((jump) => {
            if (jump.type === 2) {
                non_lj_count++;

                // Count jumps at each tick
                data.jump_tick_counts[jump.firstJumpAtTick] = (data.jump_tick_counts[jump.firstJumpAtTick] || 0) + 1;

                // Count fogs
                data.fog_counts[jump.fog] = (data.fog_counts[jump.fog] || 0) + 1;

                // If the firstJumpAtTick is different from the previous one, start a new set
                if (prev_jump_tick !== jump.firstJumpAtTick) {
                    if (current_set && current_set.amount > 1) {
                        // If the current set had more than one jump, add it to consecutive_jump_ticks
                        data.consecutive_jump_ticks['tick'+prev_jump_tick] = data.consecutive_jump_ticks['tick'+prev_jump_tick] || { sets: [] };
                        data.consecutive_jump_ticks['tick'+prev_jump_tick].sets.push(current_set);
                    }
                    current_set = { fogs: {}, amount: 0, jumpoffs: [] };
                }

                // Update fog count and amount for the current set
                current_set.fogs[jump.fog] = (current_set.fogs[jump.fog] || 0) + 1;
                current_set.amount++;
                current_set.jumpoffs.push(jump.jumpoff);

                // Update previous jump tick
                prev_jump_tick = jump.firstJumpAtTick;
            }
        });

        // Finalize the last set if it has more than one jump
        if (current_set && current_set.amount > 1) {
            data.consecutive_jump_ticks['tick'+prev_jump_tick] = data.consecutive_jump_ticks['tick'+prev_jump_tick] || { sets: [] };
            data.consecutive_jump_ticks['tick'+prev_jump_tick].sets.push(current_set);
        }

        // Store non_lj_count
        data.non_lj_count = non_lj_count;
        return data;
    }

    function readFloat32(data) {
        const dataView = new DataView(data.buffer);
        return dataView.getFloat32(0, true); // true for little-endian
    }

    function getFloat32(arr, offset) {
        const buffer = new ArrayBuffer(4); // Create a 4-byte buffer
        const view = new DataView(buffer);

        // Set the buffer to the 4 bytes from the array
        arr.slice(offset, offset + 4).forEach((b, i) => view.setUint8(i, b));

        return view.getFloat32(0, true); // Read the 32-bit float (little-endian)
    }

    function getUint8(uint8Arr, offset) {
        if (offset >= 0 && offset < uint8Arr.length) {
            return uint8Arr[offset];
        } else {
            throw new RangeError("Offset out of bounds");
        }
    }

    function parseFrames(frames) {
        const decoder = new TextDecoder('utf-8');
        
        // declare bunch of helper stuff
        const jumps_data = {};
        const ground_frames = [];
        const jump_command_frames = [];
        let jumping = false;
        let jump_frame = false;
        let jump_started_frame = false;
        let prev_frame;
        let prev_jump_frame = false;
        let prev_land = false;
        let timer_started_frame = false;
        let timer_ended_frame = false;
        let demo_user_info = false;


        function parseMessage(data) {
            if (data[0] >= 64) { /* UserMessage */
                const message = new TextDecoder().decode(data);
                return message;
            } else if (data[0] === 14) { /* SVC_DELTADESCRIPTION */
                console.log(14);
            } else if (data[0] === 41) { /* SVC_DELTAPACKETENTITIES */
                console.log(41);
            } else if (data[0] === 40) { /* SVC_PACKETENTITIES  */
                console.log(40);
            } else if (data[0] === 13) { /* SVC_UPDATEUSERINFO  */
                if (!demo_user_info) {
                    // demo user info not yet fetched
                    const raw_user_info = new TextDecoder().decode(data);
                    // Split the string by backslashes
                    const parts = raw_user_info.split('\\');
                    parts.shift();
                    const obj = {};
                    for (let i = 0; i < parts.length; i += 2) {
                        const key = parts[i];
                        let value = parts[i + 1];
                        if (value.includes('\u0000')) {
                            // if the string has null character
                            value = value.split('\u0000')[0];
                        }
                        obj[key] = value;
                    }
                    demo_user_info = obj;
                }
            } else if (data[0] === 7) { /* SVC_TIME */
                const svc_time = readFloat32(data.slice(1));
            } else {
                //console.error(`Unknown message type: ${data[0]}`);
            }
        }


        frames.forEach((frame) => {
            if (frame.frame === 0) {
                //return;
            }
            let on_ground = false;
            
            if (frame.type === 3) {
                // type 3 (ConsoleCommand)
                
                if (frame.command.includes('+jump')) {
                    jump_command_frames.push(frame.frame);
                    
                    if (prev_jump_frame == frame.frame - 1) {
                        // do nothing
                        // "if there was a bit IN_JUMP at the previous frame, then there won't be a jump at the current frame. Otherwise, we could do bhop just by holding the Space"
                        // https://kz-rush.ru/page/bhop-physics
                    } else {
                        jump_frame = frame.frame;
                        prev_jump_frame = jump_frame;
                    }
                }
            }
            
            if (frame.type === 1) {
                // frame type 1 (NetworkMessages)
                
                if (frame.demoInfo.refParams.onground === 1) {
                    on_ground = true;
                    ground_frames.push(frame.frame);
                }  
                
                if (on_ground && jump_frame == frame.frame) {
                    if (jumps_data[prev_frame] === 'air') {
                        // in some cases the previous jump ends at the same frame when the new jump begins, this is true for example if a player jumps a LJ and then proceeds to do FOG1 BJ.
                        // mark the previous frame as "land" for the previous jump - uq-checker for example works by the same logic.
                        jumps_data[prev_frame] = 'land';
                    }
                    jumps_data[frame.frame] = 'start'; 
                    jumping = true;
                    jump_started_frame = frame.frame;
                    prev_land = false;
                }
                
                if (on_ground && jump_started_frame != frame.frame && jump_frame !== false) {
                    // player lands the jump, jump ends
                    if (jumps_data[prev_land] && jumps_data[prev_land] == 'land') {
                        // the player can land one jump twice: for example when a player lands on a bhop block and gets teleported back, the player lands twice because.
                        // the first land is recorded, so we don't have to record the 2nd land.
                    } else {
                        // player lands, the jump ends
                        jumps_data[frame.frame] = 'land'; 
                        prev_land = frame.frame;
                    }
                    
                    jumping = false;
                    jump_frame = false;
                }
                
                if (!on_ground && jumping) {
                    jumps_data[frame.frame] = 'air'; // player is in the air while jumped
                }
                
                prev_frame = frame.frame;
                
                if (frame.msg)
                {
                    // get timer data here from UserMessage - do it here, because this is the only place where we loop all the frames, and we don't want to loop frames more than once (getDemoMetadata() would be more suitable function to retrieve this data, but it would require lopping the frames)
                    const user_message = parseMessage(frame.msg);
                    if (user_message && user_message.deltas) { console.log(user_message); }
                    if (user_message) {
                        if (user_message.includes('Timer started'))
                        {
                            timer_started_frame = frame;
                        }
                        if (user_message.includes('Time:'))
                        {
                            timer_ended_frame = frame;
                        }
                    }
                }
            }
        });
        
        // throw away jump data which is before and after the timer
        for (let [frame] of Object.entries(jumps_data)) {
            frame = parseInt(frame);
            if (frame < parseInt(timer_started_frame.frame) || frame > parseInt(timer_ended_frame.frame)) {
                delete jumps_data[frame];
            }
        }
        
        return {
            data: jumps_data,
            ground_frames,
            jump_command_frames,
            timer: {
                start: { frame: timer_started_frame.frame, time: timer_started_frame.time },
                end: { frame: timer_ended_frame.frame, time: timer_ended_frame.time },
            },
            user_info: demo_user_info
        };
    }
    
    function parseJumpData(jumps_data) {
        const jumps = [];
        let prev_jump_index = 0;
        const max_fog_nonlj = 10; // maximum amount of ground frames before the jump to be considered as LJ/HJ (jump plugins from KZ-Rush, Romanian-Jumper, Kreedz.ee etc. all work in a similar fashion: max FOG for non-LJ/non-HJ jump is 10)
        let index = 0;
        for (let [frame, type] of Object.entries(jumps_data.data)) {
            frame = parseInt(frame);
            // frame: frame number
            // type: type of frame ('start', 'air', 'land')
            if (type === 'start') {
                jumps[index] = {};
                jumps[index].jumpoff = frame;
                
                // if the amount of ground frames before the start of the jump is more than max_fog_nonlj, the jump is LJ or HJ
                let is_lj_hj = true;
                for (let i = frame-max_fog_nonlj; i < frame; i++) {
                    if (!jumps_data.ground_frames.includes(i)) {
                        is_lj_hj = false;
                    }
                }
                jumps[index].type = is_lj_hj ? 1 : 2; // type: 1 LJ/HJ, and 2 the rest (BJ,SBJ,CJ,DCJ,WJ... TODOOOO)
                let first_jump_at_tick = 1;
                let jump_fog = 1;
                if (!is_lj_hj) {
                    // search +jump tick count and FOG count.
                    // look +jump commands 10 frames before the jump started.
                    let seek_ticks = -10;
                    let first_jump_tick_found = false;
                    let jump_tick_count = 1;
                    let fog_found = false;
                    let fogs = 1;
                    for (let i = seek_ticks; i <= 0; i++) {
                        let seeking_frame = frame + i;
                        // search jump ticks
                        if (!first_jump_tick_found) {
                            if (jumps_data.jump_command_frames.includes(seeking_frame)) { 
                                if (seeking_frame === frame) {
                                    first_jump_at_tick = jump_tick_count;
                                    first_jump_tick_found = true;
                                }
                                jump_tick_count++;
                            }
                        }
                        // search fog
                        if (!fog_found) {
                            if (jumps_data.ground_frames.includes(seeking_frame)) {
                                if (seeking_frame === frame) {
                                    jump_fog = fogs;
                                    fog_found = true;
                                }
                                fogs++;
                            }
                        }
                    }
                }
                jumps[index].firstJumpAtTick = first_jump_at_tick;
                jumps[index].fog = jump_fog;
            } else if (type === 'land' && typeof(jumps[index]) != 'undefined') {
                jumps[index].landing = frame;
                index++;
            }
        }
        
        return jumps;
    }
    
    retrieveAllFiles()
    .then((files) => {
        files.forEach(file => {
            //console.log('Retrieved file:', file);
        });
    })
    .catch((error) => {
        console.error('Error retrieving files:', error);
    });
</script>

</body>
</html>
